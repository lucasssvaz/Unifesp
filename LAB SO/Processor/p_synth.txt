10001100000100000000000000000100	//LI $1 4		Carrega 4 no $1
10001100001000000000000000000011	//LI $2 3		Carrega 3 no $2
11111000000100001000000000000000	//SW $1 $2		Guarda o conteúdo de $2 no endereço 1 da RAM
11001000000100001100000000000000	//LW $1 $3		Carrega o conteúdo do endereço 1 da RAM no $3
10010000001100000000000000000000	//OUT $3		Printa o conteudo de $3 (3)
11010000000100001100000000000000	//MOVE $1 $3		Copia o conteudo de $1 para $3
10010000001100000000000000000000	//OUT $3		Printa $3 (4)
11110100000100001100000000000010	//SUBI $1 $3 2		Faz $3 = $1 - 2
10010000001100000000000000000000	//OUT $3		Printa $3 (2)
11010100000100001100000000000010	//MULI $1 $3 2		Faz $3 = $1 * 2
10010000001100000000000000000000	//OUT $3		Printa $3 (8)
11000100000100001100000000000010	//DIVI $1 $3 2		Faz $3 = $1 / 2
10010000001100000000000000000000	//OUT $3		Printa $3 (2)
11001100000100001100000000000010	//MODI $1 $3 2		Faz $3 = $1 % 2
10010000001100000000000000000000	//OUT $3		Printa $3 (0)
11100100000100001100000000000010	//STEQI $1 $3 2		Faz $3 = 1, se $1 = 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (0)
11101000000100001100000000000010	//STGTI $1 $3 2		Faz $3 = 1, se $1 > 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (1)
11101100000100001100000000000010	//STLTI $1 $3 2		Faz $3 = 1, se $1 < 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (0)
11110000000100001100000000000010	//STNEI $1 $3 2		Faz $3 = 1, se $1 != 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (1)
00000000000100001000001100000000	//ADD $1 $2 $3		Faz $3 = $1 + $2
10010000001100000000000000000000	//OUT $3		Printa $3 (7)
01001000000100001000001100000000	//SUB $1 $2 $3		Faz $3 = $1 - $2
10010000001100000000000000000000	//OUT $3		Printa $3 (7)
00101100000100001000001100000000	//MUL $1 $2 $3		Faz $3 = $1 * $2
10010000001100000000000000000000	//OUT $3		Printa $3 (C, 12 em hexadecimal)
00100000000100001000001100000000	//DIV $1 $2 $3		Faz $3 = $1 / $2
10010000001100000000000000000000	//OUT $3		Printa $3 (1)
00101000000100001000001100000000	//MOD $1 $2 $3		Faz $3 = $1 % $2
10010000001100000000000000000000	//OUT $3		Printa $3 (1)
00000100000100001000001100000000	//AND $1 $2 $3		Faz $3 = $1 & $2 (bitwise)
10010000001100000000000000000000	//OUT $3		Printa $3 (0)
00110100000100001000001100000000	//OR $1 $2 $3		Faz $3 = $1 | $2 (bitwise)
10010000001100000000000000000000	//OUT $3		Printa $3 (7)
01001100000100001000001100000000	//XOR $1 $2 $3		Faz $3 = $1 ^ $2 (bitwise)
10010000001100000000000000000000	//OUT $3		Printa $3 (7)
11011000000100001100000000000000	//NOT $1 $3		Faz $3 = ~$1 (bitwise)
10010000001100000000000000000000	//OUT $3		Printa $3 (FFFFFFFb)
11011100000100001100000000000001	//SHL $1 $3 1		Faz $3 = $1 << 1 (Rodado 1 posição)
10010000001100000000000000000000	//OUT $3		Printa $3 (8)
11100000000100001100000000000001	//SHR $1 $3 1		Faz $3 = $1 >> 1 (Rodado 1 posição)
10010000001100000000000000000000	//OUT $3		Printa $3 (2)
00111000000100001000001100000000	//STEQ $1 $2 $3		Faz $3 = 1, se $1 = $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (0)
00111100000100001000001100000000	//STGT $1 $2 $3		Faz $3 = 1, se $1 > $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (1)
01000000000100001000001100000000	//STLT $1 $2 $3		Faz $3 = 1, se $1 < $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (0)
01000100000100001000001100000000	//STNE $1 $2 $3		Faz $3 = 1, se $1 != $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3		Printa $3 (1)
10001100001100000000000000001111	//LI $3 15		Carrega 15(F) em $3
10001100010000000000000000111001	//LI $4 57		Carrega a linha do programa usada no próximo Branch
00001000000100001000010000000000	//BEQ $1 $2 $4		Branch caso $1 = $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3		
10010000000000000000000000000000	//OUT $0		Nesse caso Printa F depois 0
10001100010000000000000000111101	//LI $4 61		Carrega a linha do programa usada no próximo Branch
00001100000100001000010000000000	//BGE $1 $2 $4		Branch caso $1 >= $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0		Nesse caso Printa 0
10001100010000000000000001000001	//LI $4 65		Carrega a linha do programa usada no próximo Branch
00011100000100001000010000000000	//BNE $1 $2 $4		Branch caso $1 != $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0		Nesse caso Printa 0
10001100010000000000000001000101	//LI $4 69		Carrega a linha do programa usada no próximo Branch
00010100000100001000010000000000	//BLE $1 $2 $4		Branch caso $1 <= $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0		Nesse caso Printa F depois 0
10001100010000000000000001001001	//LI $4 73		Carrega a linha do programa usada no próximo Branch
00011000000100001000010000000000	//BLT $1 $2 $4		Branch caso $1 < $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0		Nesse caso Printa F depois 0
10001100010000000000000001001110	//LI $4 78		Carrega a linha do programa usada no próximo Jump
10000100010000000000000000000000	//JAL $4		Vai para a linha em $4 e armazena o retorno na pilha de retorno
00110000000000000000000000000000	//NOP			Não faz nada
00100100000000000000000000000000	//HALT			Para o processador
10010100000000000000000000000000	//RET			Retorna utilizando o topo da pilha de retorno
10010000001100000000000000000000	//OUT $3		Caso RET falhe, Printa F